<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified"
  targetNamespace="http://www.lib.virginia.edu/ns/dpla"
  xmlns:dpla="http://www.lib.virginia.edu/ns/dpla" xmlns:sch="http://purl.oclc.org/dsdl/schematron">

  <!-- someXML allows any elements that claim to be from the dcterms or edm namespaces -->
  <xs:group name="someXML">
    <xs:sequence>
      <xs:choice>
        <xs:any namespace="http://purl.org/dc/terms/" processContents="strict"/>
        <xs:any namespace="http://www.europeana.eu/schemas/edm/" processContents="lax"/>
      </xs:choice>
    </xs:sequence>
  </xs:group>

  <!-- An individual metadata record -->
  <xs:element name="mdRecord">
    <xs:complexType>
      <xs:group maxOccurs="unbounded" ref="dpla:someXML"/>
    </xs:complexType>
  </xs:element>

  <!-- * Embedded Schematron * -->
  <!-- Schematron namespace declarations -->
  <xs:annotation>
    <xs:appinfo>
      <ns xmlns="http://purl.oclc.org/dsdl/schematron" prefix="dcterms"
        uri="http://purl.org/dc/terms/"/>
      <ns xmlns="http://purl.oclc.org/dsdl/schematron" prefix="edm"
        uri="http://www.europeana.eu/schemas/edm/"/>
    </xs:appinfo>
  </xs:annotation>

  <!-- Check DPLA requirements for mdRecord -->
  <xs:annotation>
    <xs:appinfo>
      <sch:pattern>
        <sch:rule context="*:mdRecord">
          <sch:assert test="dcterms:provenance">At least one dcterms:provenance element is
            required.</sch:assert>
          <sch:assert test="dcterms:rights">At least one dcterms:rights element is
            required.</sch:assert>
          <sch:assert test="dcterms:title">At least one dcterms:title element is
            required.</sch:assert>
          <sch:assert test="edm:isShownAt">At least one edm:isShownAt element is
            required.</sch:assert>
          <sch:assert test="edm:preview">At least one edm:preview element is required.</sch:assert>
        </sch:rule>
      </sch:pattern>
    </xs:appinfo>
  </xs:annotation>

  <!-- Check dcterms elements -->
  <xs:annotation>
    <xs:appinfo>
      <sch:pattern>
        <sch:rule context="dcterms:*">
          <!-- Allow only actual dcterms elements -->
          <!--<sch:assert
            test="
              matches(local-name(),
              '^(abstract|accessRights|accrualMethod|accrualPeriodicity|accrualPolicy|alternative|audience|available|bibliographicCitation|conformsTo|contributor|coverage|created|creator|date|dateAccepted|dateCopyrighted|dateSubmitted|description|educationLevel|extent|format|hasFormat|hasPart|hasVersion|identifier|instructionalMethod|isFormatOf|isPartOf|isReferencedBy|isReplacedBy|isRequiredBy|issued|isVersionOf|language|license|mediator|medium|modified|provenance|publisher|references|relation|replaces|requires|rights|rightsHolder|source|spatial|subject|tableOfContents|temporal|title|type|valid)$')"
            ><sch:name/> not permitted; only abstract, accessRights, accrualMethod,
            accrualPeriodicity, accrualPolicy, alternative, audience, available,
            bibliographicCitation, conformsTo, contributor, coverage, created, creator, date,
            dateAccepted, dateCopyrighted, dateSubmitted, description, educationLevel, extent,
            format, hasFormat, hasPart, hasVersion, identifier, instructionalMethod, isFormatOf,
            isPartOf, isReferencedBy, isReplacedBy, isRequiredBy, issued, isVersionOf, language,
            license, mediator, medium, modified, provenance, publisher, references, relation,
            replaces, requires, rights, rightsHolder, source, spatial, subject, tableOfContents,
            temporal, title, type, or valid elements are allowed.</sch:assert>-->
          <!-- Elements must have textual content -->
          <sch:assert test="text()"><sch:name/> must have content.</sch:assert>
        </sch:rule>
      </sch:pattern>
    </xs:appinfo>
  </xs:annotation>

  <!-- Check edm elements -->
  <xs:annotation>
    <xs:appinfo>
      <sch:pattern>
        <sch:rule context="edm:*">
          <!-- Allow only actual edm elements -->
          <sch:assert test="matches(local-name(), '^(isShownAt|preview)$')"><sch:name/> not
            permitted; only isShownAt and preview elements are allowed.</sch:assert>
          <!-- Elements must have textual content -->
          <sch:assert test="text()"><sch:name/> must have content.</sch:assert>
        </sch:rule>
      </sch:pattern>
    </xs:appinfo>
  </xs:annotation>

  <!-- dcterms:created should comply with level 1 of the Extend Date Time Format (EDTF). -->
  <!-- See http://www.loc.gov/standards/datetime/ISO_DIS%208601-2.pdf for format details. -->
  <!-- Some MARC values are also allowed to facilitate conversion from existing MARC records. -->
  <xs:annotation>
    <xs:appinfo>
      <sch:pattern>
        <sch:rule context="dcterms:created[not(matches(., '/'))]">
          <sch:let name="dateTime" value="replace(., '\s', '')"/>
          <sch:assert role="warning"
            test="
              matches(., '^[\s]{4}$') or
              matches($dateTime, '^[\|]{4}$') or matches($dateTime, '^[9]{4}$') or
              matches($dateTime, '^y-?\d{4,}(~|\?|%)?$') or
              matches($dateTime, '^-?\d{2}(\d{2}|uu|\du)-(21|22|23|24)(~|\?|%)?$') or
              matches($dateTime, '^-?\d{2}(\d{2}|uu|\du)(-(01|03|05|07|08|10|12|uu)(-(0[1-9]|[1-2][0-9]|3[0-1]|uu))?)?(~|\?|%)?$') or
              matches($dateTime, '^-?\d{2}(\d{2}|uu|\du)(-(04|06|09|11|uu)(-(0[1-9]|[1-2][0-9]|30|uu))?)?(~|\?|%)?$') or
              matches($dateTime, '^-?\d{2}(\d{2}|uu|\du)(-(02|uu)(-(0[1-9]|[1-2][0-9]|uu))?)?(~|\?|%)?$') or
              matches($dateTime, '^[1-9]\d{3}-(((01|03|05|07|08|10|12)-(0[1-9]|[1-2][0-9]|3[0-1]))|((04|06|09|11)(-(0[1-9]|[1-2][0-9]|30))|((02)(-(0[1-9]|[1-2][0-9])))))(T([01][0-9]|2[0-3]):([0-5][0-9])([\.,]\d+)?(:([0-5][0-9]|60)([\.,]\d+)?)?(Z|(\+|-)([01][0-9]|2[0-3])((:[0-5][0-9]([\.,]\d+)?)(:[0-5][0-9]([\.,]\d+)?)?)?)?)?$')"
            >Warning: Suspect value, please verify.</sch:assert>
          <sch:assert role="warning" test="not(matches($dateTime, '^-0+$'))">Warning: Suspect value,
            please verify.</sch:assert>
        </sch:rule>
        <sch:rule context="dcterms:created[matches(., '/')]">
          <sch:let name="dateTime1" value="substring-before(replace(., '\s', ''), '/')"/>
          <sch:let name="dateTime2" value="substring-after(replace(., '\s', ''), '/')"/>
          <sch:assert role="warning"
            test="
              matches($dateTime1, '^\.\.$') or
              matches($dateTime1, '^$') or
              matches($dateTime1, '^[\|]{4}$') or
              matches($dateTime1, '^[9]{4}$') or
              matches($dateTime1, '^y-?\d{4,}(~|\?|%)?$') or
              matches($dateTime1, '^-?\d{2}(\d{2}|uu|\du)-(21|22|23|24)(~|\?|%)?$') or
              matches($dateTime1, '^-?\d{2}(\d{2}|uu|\du)(-(01|03|05|07|08|10|12|uu)(-(0[1-9]|[1-2][0-9]|3[0-1]|uu))?)?(~|\?|%)?$') or
              matches($dateTime1, '^-?\d{2}(\d{2}|uu|\du)(-(04|06|09|11|uu)(-(0[1-9]|[1-2][0-9]|30|uu))?)?(~|\?|%)?$') or
              matches($dateTime1, '^-?\d{2}(\d{2}|uu|\du)(-(02|uu)(-(0[1-9]|[1-2][0-9]|uu))?)?(~|\?|%)?$') or
              matches($dateTime1, '^[1-9]\d{3}-(((01|03|05|07|08|10|12)-(0[1-9]|[1-2][0-9]|3[0-1]))|((04|06|09|11)(-(0[1-9]|[1-2][0-9]|30))|((02)(-(0[1-9]|[1-2][0-9])))))(T([01][0-9]|2[0-3]):([0-5][0-9])([\.,]\d+)?(:([0-5][0-9]|60)([\.,]\d+)?)?(Z|(\+|-)([01][0-9]|2[0-3])((:[0-5][0-9]([\.,]\d+)?)(:[0-5][0-9]([\.,]\d+)?)?)?)?)?$')"
            >Warning: Start of range '<sch:value-of select="$dateTime1"/>' suspect value, please
            verify.</sch:assert>
          <sch:assert role="warning" test="not(matches($dateTime1, '^-0+$'))">Warning: Start of
            range '<sch:value-of select="$dateTime1"/>' suspect value, please verify.</sch:assert>
          <sch:assert role="warning"
            test="
              matches($dateTime2, '^\.\.$') or
              matches($dateTime2, '^$') or
              matches($dateTime2, '^[\|]{4}$') or
              matches($dateTime2, '^[9]{4}$') or
              matches($dateTime2, '^y-?\d{4,}(~|\?|%)?$') or
              matches($dateTime2, '^-?\d{2}(\d{2}|uu|\du)-(21|22|23|24)(~|\?|%)?$') or
              matches($dateTime2, '^-?\d{2}(\d{2}|uu|\du)(-(01|03|05|07|08|10|12|uu)(-(0[1-9]|[1-2][0-9]|3[0-1]|uu))?)?(~|\?|%)?$') or
              matches($dateTime2, '^-?\d{2}(\d{2}|uu|\du)(-(04|06|09|11|uu)(-(0[1-9]|[1-2][0-9]|30|uu))?)?(~|\?|%)?$') or
              matches($dateTime2, '^-?\d{2}(\d{2}|uu|\du)(-(02|uu)(-(0[1-9]|[1-2][0-9]|uu))?)?(~|\?|%)?$') or
              matches($dateTime2, '^[1-9]\d{3}-(((01|03|05|07|08|10|12)-(0[1-9]|[1-2][0-9]|3[0-1]))|((04|06|09|11)(-(0[1-9]|[1-2][0-9]|30))|((02)(-(0[1-9]|[1-2][0-9])))))(T([01][0-9]|2[0-3]):([0-5][0-9])([\.,]\d+)?(:([0-5][0-9]|60)([\.,]\d+)?)?(Z|(\+|-)([01][0-9]|2[0-3])((:[0-5][0-9]([\.,]\d+)?)(:[0-5][0-9]([\.,]\d+)?)?)?)?)?$')"
            >Warning: End of range '<sch:value-of select="$dateTime2"/>' suspect value, please
            verify.</sch:assert>
          <sch:assert role="warning" test="not(matches($dateTime2, '^-0+$'))">Warning: End of range
              '<sch:value-of select="$dateTime2"/>' suspect value, please verify.</sch:assert>
          <sch:assert role="warning"
            test="not(matches($dateTime1, '^$') and matches($dateTime2, '^$'))">Warning: start and
            end both unknown, please verify.</sch:assert>
          <sch:assert role="warning"
            test="not(matches($dateTime1, '^\.\.$') and matches($dateTime2, '^\.\.$'))">Warning:
            start and end both open, please verify.</sch:assert>
          <sch:assert role="warning"
            test="not(matches($dateTime1, '^$') and matches($dateTime2, '^\.\.$'))">Warning: start
            unknown and end open, please verify.</sch:assert>
          <sch:assert role="warning"
            test="not(matches($dateTime1, '^\.\.$') and matches($dateTime2, '^$'))">Warning: start
            open and end unknown, please verify.</sch:assert>
        </sch:rule>
      </sch:pattern>
    </xs:appinfo>
  </xs:annotation>

  <!-- dcterms:identifier cannot contain a space character -->
  <xs:annotation>
    <xs:appinfo>
      <sch:pattern>
        <sch:rule context="dcterms:identifier">
          <sch:assert test="matches(normalize-space(.), '^[^ ]+$')"><sch:name/> cannot contain space
            characters.</sch:assert>
        </sch:rule>
      </sch:pattern>
    </xs:appinfo>
  </xs:annotation>

  <!-- dcterms:rights, edm:preview, and edm:isShownAt must contain an absolute URI -->
  <xs:annotation>
    <xs:appinfo>
      <sch:pattern>
        <sch:rule context="dcterms:rights | edm:preview | edm:isShownAt">
          <sch:assert test="matches(normalize-space(.), '^([a-z]+://)')">Invalid absolute URI;
            <sch:name/> must match the pattern "^([a-z]+://)".</sch:assert>
          <!-- Regex can be read as "one or more alphabetic characters, followed by a colon and two slashes." -->
        </sch:rule>
      </sch:pattern>
    </xs:appinfo>
  </xs:annotation>

  <!-- dcterms:type must match one of the enumerated values -->
  <xs:annotation>
    <xs:appinfo>
      <sch:pattern>
        <sch:rule context="dcterms:type">
          <sch:assert
            test="
              matches(normalize-space(.),
              '^(Collection|Dataset|Event|Image|Interactive Resource|Moving Image|Physical Object|Service|Software|Sound|Still Image|Text)$', 'i')"
              >"<sch:value-of select="."/>" not permitted; <sch:name/> must match "Collection,
            Dataset, Event, Image, Interactive Resource, Moving Image, Physical Object, Service,
            Software, Sound, Still Image, or Text"</sch:assert>
        </sch:rule>
      </sch:pattern>
    </xs:appinfo>
  </xs:annotation>

  <!-- dcterms:language required when dcterms:type matches "Text" -->
  <xs:annotation>
    <xs:appinfo>
      <sch:pattern>
        <sch:rule context="dcterms:type[matches(., 'Text', 'i')]">
          <sch:assert test="../dcterms:language">dcterms:language is required when <sch:name/>
            matches "Text".</sch:assert>
        </sch:rule>
      </sch:pattern>
    </xs:appinfo>
  </xs:annotation>

</xs:schema>
